<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Clip Checker</title>
<style>
html, body { background:#222; font-family: Arial; color:white; margin:0; padding:20px; }
.banner { text-align:center; padding:20px; font-size:32px; border-bottom:2px solid #00bfff; margin-bottom:25px; }
#dropzone {
  border:2px dashed #00bfff; padding:50px; text-align:center;
  border-radius:10px; background:#333; margin-bottom:20px; font-size:20px;
}
#result { margin-top:20px; }
.card {
  border:1px solid #00bfff;
  padding:15px;
  margin-top:10px;
  border-radius:8px;
  background:#2a2a2a;
}
.card-title {
  font-size:20px;
  font-weight:bold;
  margin-bottom:10px;
  color:#00bfff;
}
.row { margin-bottom:6px; }
.label { color:#00bfff; }
.value { color:white; }
.details-toggle {
  cursor:pointer;
  margin-top:10px;
  color:#00bfff;
  font-size:18px;
}
.hidden { display:none; }
</style>
</head>
<body>

<div class="banner">ðŸŽ¥ Clip Checker</div>

<div id="dropzone">Drop MP4 file here</div>
<div id="result"></div>

<script>
// Utility
function fmtBytes(bytes){
  const sizes=["B","KB","MB","GB"];
  let i=Math.floor(Math.log(bytes)/Math.log(1024));
  return (bytes/Math.pow(1024,i)).toFixed(2)+" "+sizes[i];
}
function fmtTime(sec){
  if(!sec) return "Unknown";
  let m=Math.floor(sec/60), s=Math.floor(sec%60);
  return m+"m "+s+"s";
}

// Parse MP4
async function analyzeFile(file){
  return new Promise((resolve)=>{
    let reader=new FileReader();
    reader.onload=function(){
      let buf=reader.result;
      let v=new DataView(buf);

      function readString(off,len){
        let s=""; for(let i=0;i<len;i++) s+=String.fromCharCode(v.getUint8(off+i));
        return s;
      }

      // parse boxes
      let pos=0, boxes=[];
      while(pos+8<=buf.byteLength){
        let size=v.getUint32(pos), type=readString(pos+4,4);
        if(size<8) break;
        boxes.push({type,start:pos,end:pos+size});
        pos+=size;
      }

      let ftyp=boxes.find(b=>b.type==="ftyp");
      let moov=boxes.find(b=>b.type==="moov");

      // brands
      let brands=[];
      if(ftyp){
        brands.push(readString(ftyp.start+8,4));
        for(let i=ftyp.start+16;i<ftyp.end;i+=4){
          brands.push(readString(i,4));
        }
      }

      // find stsd and smart-detect codec + resolution
      let codec="Unknown", width=null, height=null;
      function searchStsd(){
        if(!moov) return;
        for(let i=moov.start;i<moov.end;i++){
          if(readString(i,4)==="stsd"){
            // search for known codec signatures
            let region = new Uint8Array(buf.slice(i, i+300));
            let text = Array.from(region).map(c=>String.fromCharCode(c)).join("");
            let candidates=["avc1","hvc1","av01","vp09"];
            for(let c of candidates){
              let idx=text.indexOf(c);
              if(idx!==-1){ codec=c; }
            }
            // try extracting width/height by scanning for valid pairs
            for(let k=i;k<i+300;k++){
              try{
                let w=v.getUint16(k);
                let h=v.getUint16(k+2);
                if(w>100 && h>100 && w<10000 && h<10000){
                  width=w; height=h; return;
                }
              }catch{}
            }
          }
        }
      }
      searchStsd();

      // Accurate duration detection (mdhd > mvhd fallback)
let duration = null;
let timescale = null;
let tracks = 0;

if (moov) {
  for (let i = moov.start; i < moov.end; i++) {

    // Count tracks
    if (readString(i, 4) === "trak") tracks++;

    // mdhd â€” BEST source of clip duration
    if (readString(i, 4) === "mdhd") {
      let version = v.getUint8(i + 8);

      if (version === 0) {
        // version 0 (32-bit duration)
        timescale = v.getUint32(i + 20);
        duration  = v.getUint32(i + 24);
      } else if (version === 1) {
        // version 1 (64-bit duration, take lower 32 bits)
        timescale = v.getUint32(i + 28);
        duration  = v.getUint32(i + 36 + 4);
      }
    }

    // mvhd fallback â€” only used if mdhd wasn't found
    if (readString(i, 4) === "mvhd" && duration === null) {
      timescale = v.getUint32(i + 20);
      duration  = v.getUint32(i + 24);
    }
  }
}
// Recorder inference
      let recorder="Unknown Recorder";

      if(codec==="avc1" || codec==="hvc1"){
        if(brands.includes("mp41")||brands.includes("mp42")||brands.includes("isom")){
          recorder="NVIDIA ShadowPlay";
        }
      }

      if(height===1088) recorder="Windows Game Bar";
      if(brands.join(",").toLowerCase().includes("med")) recorder="Medal.tv";
      if(codec==="av01") recorder="OBS (AV1)";
      if(brands.includes("qt  ")) recorder="OBS (QuickTime)";

      // GPU vendor
      let gpu="Unknown";
      if(recorder==="NVIDIA ShadowPlay") gpu="NVIDIA";
      if(recorder==="OBS (AV1)") gpu="Likely NVIDIA/AMD";
      if(recorder==="Windows Game Bar") gpu="Microsoft (WDDM)";

      // Verdict
      let verdict = recorder==="NVIDIA ShadowPlay" ? 
        "VALID â€” NVIDIA Recording" : "INVALID â€” Non-NVIDIA";

      resolve({
        verdict,
        forensic:{
          "File Name":file.name,
          "Recorder":recorder,
          "GPU Vendor":gpu,
          "Brands":brands.join(", "),
          "Codec":codec,
          "Resolution": (width&&height) ? width+" x "+height : "Unknown",
          "Tracks":tracks,
          "File Size":fmtBytes(file.size),
          "Duration": (duration&&timescale)? fmtTime(duration/timescale) : "Unknown"
        }
      });

    };
    reader.readAsArrayBuffer(file);
  });
}

// UI
document.getElementById("dropzone").addEventListener("dragover",e=>e.preventDefault());
document.getElementById("dropzone").addEventListener("drop",async e=>{
  e.preventDefault();
  let file=e.dataTransfer.files[0];
  let result=await analyzeFile(file);
  let container=document.getElementById("result");
  container.innerHTML="";

  let verdictBox=document.createElement("div");
  verdictBox.style.fontSize="24px";
  verdictBox.style.marginBottom="15px";
  verdictBox.textContent=result.verdict;
  container.appendChild(verdictBox);

  let toggle=document.createElement("div");
  toggle.className="details-toggle";
  toggle.textContent="Show / Hide Forensic Details";
  toggle.onclick=()=>card.classList.toggle("hidden");
  container.appendChild(toggle);

  let card=document.createElement("div");
  card.className="card hidden";

  let title=document.createElement("div");
  title.className="card-title";
  title.textContent="Forensic Details";
  card.appendChild(title);

  for(let key in result.forensic){
    let row=document.createElement("div");
    row.className="row";
    let label=document.createElement("span");
    label.className="label";
    label.textContent=key+": ";
    let value=document.createElement("span");
    value.className="value";
    value.textContent=result.forensic[key];
    row.appendChild(label);
    row.appendChild(value);
    card.appendChild(row);
  }

  container.appendChild(card);
});
</script>

</body>
</html>