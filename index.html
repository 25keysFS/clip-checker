<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Clip Checker</title>
<style>
html, body { background:#222; font-family: Arial; color:white; margin:0; padding:20px; }
.banner { text-align:center; padding:20px; font-size:32px; border-bottom:2px solid #00bfff; margin-bottom:25px; }
#dropzone {
  border:2px dashed #00bfff; padding:50px; text-align:center;
  border-radius:10px; background:#333; margin-bottom:20px; font-size:20px;
}
#result { margin-top:20px; }
.card {
  border:1px solid #00bfff;
  padding:15px;
  margin-top:10px;
  border-radius:8px;
  background:#2a2a2a;
}
.card-title {
  font-size:20px;
  font-weight:bold;
  margin-bottom:10px;
  color:#00bfff;
}
.row { margin-bottom:6px; }
.label { color:#00bfff; }
.value { color:white; }
</style>
</head>
<body>

<div class="banner">ðŸŽ¥ Clip Checker</div>

<div id="dropzone">Drop MP4 file here</div>
<div id="result"></div>

<script>
// Utility
function fmtBytes(bytes){
  const sizes=["B","KB","MB","GB"];
  let i=Math.floor(Math.log(bytes)/Math.log(1024));
  return (bytes/Math.pow(1024,i)).toFixed(2)+" "+sizes[i];
}
function fmtTime(sec){
  if(!sec) return "Unknown";
  let m=Math.floor(sec/60), s=Math.floor(sec%60);
  return m+"m "+s+"s";
}

// Parse MP4
async function analyzeFile(file){
  return new Promise((resolve)=>{
    let reader=new FileReader();
    reader.onload=function(){
      let buf=reader.result;
      let v=new DataView(buf);

      function readString(off,len){
        let s=""; for(let i=0;i<len;i++) s+=String.fromCharCode(v.getUint8(off+i));
        return s;
      }

      // parse boxes
      let pos=0, boxes=[];
      while(pos+8<=buf.byteLength){
        let size=v.getUint32(pos), type=readString(pos+4,4);
        if(size<8) break;
        boxes.push({type,start:pos,end:pos+size});
        pos+=size;
      }

      let ftyp=boxes.find(b=>b.type==="ftyp");
      let moov=boxes.find(b=>b.type==="moov");

      // brands
      let brands=[];
      if(ftyp){
        brands.push(readString(ftyp.start+8,4));
        for(let i=ftyp.start+16;i<ftyp.end;i+=4){
          brands.push(readString(i,4));
        }
      }

      // find stsd and smart-detect codec + resolution
      let codec="Unknown", width=null, height=null;
      function searchStsd(){
        if(!moov) return;
        for(let i=moov.start;i<moov.end;i++){
          if(readString(i,4)==="stsd"){
            let region = new Uint8Array(buf.slice(i, i+400));
            let text = Array.from(region).map(c=>String.fromCharCode(c)).join("");
            let candidates=["avc1","hvc1","av01","vp09"];
            for(let c of candidates){
              let idx=text.indexOf(c);
              if(idx!==-1){ codec=c; }
            }
            for(let k=i;k<i+400;k++){
              try{
                let w=v.getUint16(k);
                let h=v.getUint16(k+2);
                if(w>100 && h>100 && w<10000 && h<10000){
                  width=w; height=h; return;
                }
              }catch{}
            }
          }
        }
      }
      searchStsd();

      // duration + timescale from mdhd > mvhd fallback
      let duration=null, timescale=null, tracks=0;
      if(moov){
        for(let i=moov.start;i<moov.end;i++){
          if(readString(i,4)==="trak") tracks++;

          if(readString(i,4)==="mdhd"){
            let version=v.getUint8(i+8);
            if(version===0){
              timescale=v.getUint32(i+20);
              duration=v.getUint32(i+24);
            } else {
              timescale=v.getUint32(i+28);
              duration=v.getUint32(i+36+4);
            }
          }

          if(readString(i,4)==="mvhd" && duration===null){
            timescale=v.getUint32(i+20);
            duration=v.getUint32(i+24);
          }
        }
      }

      let seconds=(duration&&timescale)? duration/timescale : 0;

      // Bitrate estimation
      let bitrate = (file.size * 8) / (seconds || 1);

      // Fake detection heuristics
      let suspicious = [];
      if(bitrate < 500000) suspicious.push("Very low bitrate â€” possible re-encode");
      if(width % 2 !== 0 || height % 2 !== 0) suspicious.push("Non-even resolution â€” unusual for ShadowPlay");

      // Recorder detection
      let recorder="Unknown Recorder";
      if(codec==="avc1" || codec==="hvc1"){
        if(brands.includes("mp41")||brands.includes("mp42")||brands.includes("isom")){
          recorder="NVIDIA ShadowPlay";
        }
      }
      if(height===1088) recorder="Windows Game Bar";
      if(brands.join(",").toLowerCase().includes("med")) recorder="Medal.tv";
      if(codec==="av01") recorder="OBS (AV1)";
      if(brands.includes("qt  ")) recorder="OBS (QuickTime)";

      // GPU Vendor
      let gpu="Unknown";
      if(recorder==="NVIDIA ShadowPlay") gpu="NVIDIA";
      if(recorder==="OBS (AV1)") gpu="Likely NVIDIA/AMD";
      if(recorder==="Windows Game Bar") gpu="Microsoft (WDDM)";

      // Verdict
      let verdict = recorder==="NVIDIA ShadowPlay" ? 
        "VALID â€” NVIDIA Recording" : "INVALID â€” Non-NVIDIA";

      resolve({
        verdict,
        forensic:{
          "File Name":file.name,
          "Recorder":recorder,
          "GPU Vendor":gpu,
          "Brands":brands.join(", "),
          "Codec":codec,
          "Resolution": (width&&height) ? width+" x "+height : "Unknown",
          "Tracks":tracks,
          "File Size":fmtBytes(file.size),
          "Duration": fmtTime(seconds),
          "Bitrate": (bitrate/1000000).toFixed(2)+" Mbps",
          "Suspicious Flags": suspicious.length? suspicious.join("; ") : "None detected"
        }
      });

    };
    reader.readAsArrayBuffer(file);
  });
}

// UI
document.getElementById("dropzone").addEventListener("dragover",e=>e.preventDefault());
document.getElementById("dropzone").addEventListener("drop",async e=>{
  e.preventDefault();
  let file=e.dataTransfer.files[0];
  let result=await analyzeFile(file);
  let container=document.getElementById("result");
  container.innerHTML="";

  let verdictBox=document.createElement("div");
  verdictBox.style.fontSize="24px";
  verdictBox.style.marginBottom="15px";
  verdictBox.textContent=result.verdict;
  container.appendChild(verdictBox);

  let card=document.createElement("div");
  card.className="card";

  let title=document.createElement("div");
  title.className="card-title";
  title.textContent="Forensic Details";
  card.appendChild(title);

  for(let key in result.forensic){
    let row=document.createElement("div");
    row.className="row";
    let label=document.createElement("span");
    label.className="label";
    label.textContent=key+": ";
    let value=document.createElement("span");
    value.className="value";
    value.textContent=result.forensic[key];
    row.appendChild(label);
    row.appendChild(value);
    card.appendChild(row);
  }

  container.appendChild(card);
});
</script>

</body>
</html>